{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QtGQL","text":"<p> GraphQL client for Qt and QML. This library is an attempt to provide a high-level graphql client to the QT world.</p>"},{"location":"#similar-projects","title":"Similar projects","text":"<ul> <li>react-relay</li> <li>apollo-client</li> </ul>"},{"location":"#features","title":"Features","text":"<p>Codegen (introspection compiler)</p> <ul> <li> Object types, for each field there is a corresponding <code>Property</code></li> <li> Enums</li> <li> Custom scalars</li> <li> Unions</li> <li> Query handlers: queries your server when a component uses this query (or imperatively fetched).</li> <li> Query updates: fetch the same query multiple times would not instantiate everything from scratch</li> </ul> <p>Network layer</p> <ul> <li> \"Qt-native\" graphql-transport-ws network manager (supports subscriptions).</li> </ul> <p>Helpers</p> <ul> <li> generic models that get created from dictionaries (with update, pop, insert implemented by default)</li> <li> <code>Property</code> classes that are accessible from QML, with dataclasses  syntax (using attrs)</li> <li> <code>@slot</code> - decorator to be replaced with <code>QtCore.Slot()</code> that get types from type hints.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>// This would install our codegen dependencies as well...\n$ pip install qtgql[codegen]\n---&gt; 100%\n</code></pre>"},{"location":"codegen/config/","title":"Configurations","text":""},{"location":"codegen/config/#codegen.py.compiler.config.QtGqlConfig","title":"<code>QtGqlConfig</code>","text":"<p>Encapsulates configurations for a qtgql-codegen application per GraphQL schema.</p> Source code in <code>codegen/py/compiler/config.py</code> <pre><code>@define\nclass QtGqlConfig:\n\"\"\"Encapsulates configurations for a qtgql-codegen application per GraphQL\n    schema.\"\"\"\ngraphql_dir: Path\n\"\"\"A directory contains [schema.graphql, query.graphql, mutation.graphql,\n    subscription.graphql] generated types come from the schema.\n    and queries, mutations, subscription handlers would be generated\n    from the corresponding `.graphql` files.\n    \"\"\"\nenv_name: str = \"QGqlEnv\"\n\"\"\"The generated types would find the environment by this name.\n    Also the generated QML imports would fall under this namespace.\n    \"\"\"\nevaluator: Type[SchemaEvaluator] = SchemaEvaluator\n\"\"\"evaluates the schema and generates types.\"\"\"\ncustom_scalars: CustomScalarMap = CUSTOM_SCALARS\n\"\"\"mapping of custom scalars, respected by the schema evaluator.\"\"\"\ntemplate_class: Callable[[TemplateContext], str] = schema_types_template\n\"\"\"jinja template.\"\"\"\nbase_object: Type[_BaseQGraphQLObject] = BaseGraphQLObject\n\"\"\"base object to be extended by all generated types.\"\"\"\n@property\ndef schema_path(self) -&gt; Path:\nreturn self.graphql_dir / \"schema.graphql\"\n@property\ndef operations_dir(self) -&gt; Path:\nreturn self.graphql_dir / \"operations.graphql\"\n@property\ndef generated_types_dir(self) -&gt; Path:\nreturn self.graphql_dir / \"objecttypes.py\"\n@property\ndef generated_handlers_dir(self) -&gt; Path:\nreturn self.graphql_dir / \"handlers.py\"\ndef generate(self) -&gt; None:\nself.evaluator(self).dump()\ndef __attrs_post_init__(self):\nif self.custom_scalars != CUSTOM_SCALARS:\nself.custom_scalars.update(CUSTOM_SCALARS)\n</code></pre>"},{"location":"codegen/config/#codegen.py.compiler.config.QtGqlConfig.base_object","title":"<code>base_object: Type[_BaseQGraphQLObject] = BaseGraphQLObject</code>  <code>class-attribute</code>","text":"<p>base object to be extended by all generated types.</p>"},{"location":"codegen/config/#codegen.py.compiler.config.QtGqlConfig.custom_scalars","title":"<code>custom_scalars: CustomScalarMap = CUSTOM_SCALARS</code>  <code>class-attribute</code>","text":"<p>mapping of custom scalars, respected by the schema evaluator.</p>"},{"location":"codegen/config/#codegen.py.compiler.config.QtGqlConfig.env_name","title":"<code>env_name: str = 'QGqlEnv'</code>  <code>class-attribute</code>","text":"<p>The generated types would find the environment by this name.</p> <p>Also the generated QML imports would fall under this namespace.</p>"},{"location":"codegen/config/#codegen.py.compiler.config.QtGqlConfig.evaluator","title":"<code>evaluator: Type[SchemaEvaluator] = SchemaEvaluator</code>  <code>class-attribute</code>","text":"<p>evaluates the schema and generates types.</p>"},{"location":"codegen/config/#codegen.py.compiler.config.QtGqlConfig.graphql_dir","title":"<code>graphql_dir: Path</code>  <code>class-attribute</code>","text":"<p>A directory contains [schema.graphql, query.graphql, mutation.graphql, subscription.graphql] generated types come from the schema.</p> <p>and queries, mutations, subscription handlers would be generated from the corresponding <code>.graphql</code> files.</p>"},{"location":"codegen/config/#codegen.py.compiler.config.QtGqlConfig.template_class","title":"<code>template_class: Callable[[TemplateContext], str] = schema_types_template</code>  <code>class-attribute</code>","text":"<p>jinja template.</p>"},{"location":"codegen/tutorial/","title":"Graphql Codegen","text":""},{"location":"codegen/tutorial/#intro","title":"Intro","text":"<p>TBD</p>"},{"location":"codegen/tutorial/#setup","title":"Setup","text":"<p>Set up a <code>.graphql</code> dir inside it create a file named <code>schema.graphql</code> (dump your schema SDL there) and another file named <code>operations.graphql</code> and declare the queries you want to use there.</p> <p>Point your config to that directory <pre><code># myapp/config.py\nfrom qtgql.codegen.py.compiler.config import QtGqlConfig\nfrom pathlib import Path\n# normally you would use `Path(__file__).parent` though this doc is tested\n# and has no __file__...\nmyconfig = QtGqlConfig(graphql_dir= Path.cwd() / '.graphql')\n</code></pre> Now in your <code>pyproject.toml</code> add the full import path for <code>myconfig</code>:</p> <p><pre><code>[ tool.qtgql ]\nconfig = \"myapp.config:myconfig\"\n</code></pre> Now <code>qtgql</code> knows how to query your server for introspection data, you just need to call</p> <pre><code>// Make sure the server is on \ud83d\ude09\n$ poetry run qtgql gen\n\n---&gt; 100%\n</code></pre> <p>And your typed are generated...</p>"},{"location":"codegen/tutorial/#note-about-optionals","title":"Note about optionals","text":"<p>This library will try to set default values for fields if they were not fetched by the query or to be used by <code>QGraphQListModel.currentObject</code>, This reduces unexpected bugs significantly.</p> <p>Note</p> <p>Object types are currently optional because two types can refer each-other and cause recursion error, see #84</p> <p><pre><code>Item{\nproperty int size: object?.size\n}\n</code></pre> If <code>object</code> would be null property assignment would fail since you can't assign <code>undefined</code> to <code>int</code>.</p> <p>Therefore, every generated type has a default value, including scalars and custom-scalars.</p>"},{"location":"codegen/tutorial/#defaults-mapping","title":"Defaults mapping","text":"GraphQL type Default <code>Int</code> <code>0</code> <code>String</code> <code>\" - \"</code> <code>Float</code> <code>0.0</code> <code>ID</code> <code>'9b2a0828-880d-4023-9909-de067984523c'</code> <code>Boolean</code> <code>False</code> <code>UUID</code> <code>'9b2a0828-880d-4023-9909-de067984523c'</code> <code>List</code> or in our context a <code>QAbstractListModel</code> <code>&lt;modelname&gt;</code> Blank corresponding generated model <code>ObjectType</code> or in our context an <code>QObject</code> with properties <code>None</code> <code>SCALAR</code> Provided by scalar implementation."},{"location":"codegen/tutorial/#usage","title":"Usage","text":"<p>(TBD)</p>"},{"location":"codegen/scalars/","title":"Scalars","text":"<p>The GraphQL specification includes default scalar types Int, Float, String, Boolean, and ID. Although these scalars cover the majority of use cases, some applications need to support other atomic data types (such as Date) or add validation to an existing type. To enable this, you can define custom scalar types.</p>"},{"location":"codegen/scalars/#builtins-scalars","title":"'Builtins' scalars","text":"<p>These scalars are represented by a Python \"builtin\" type, These are basically \"no-op\" scalars since we won't modify the value came from the <code>json</code> response.</p> <ul> <li><code>String</code>, maps to Python\u2019s <code>str</code></li> <li><code>Int</code>, a signed 32-bit integer, maps to Python\u2019s <code>int</code></li> <li><code>Float</code>, a signed double-precision floating-point value, maps to Python\u2019s <code>float</code></li> <li><code>Boolean</code>, true or false, maps to Python\u2019s <code>bool</code></li> <li><code>ID</code>, a specialised <code>String</code> for representing unique object identifiers</li> <li><code>UUID</code>, maps to Python\u2019s <code>str</code></li> </ul> <p>UUID scalar</p> <p>Although you could expect of UUID to map to Python's UUID Since it would come with performance penalty and the advantages are nominal, we decided to stick with a no-op scalar.</p>"},{"location":"codegen/scalars/create_scalar/","title":"Create Your own custom scalar","text":"<p>Although QtGQL provides some frequently used scalars, you might have your own complex scalars.</p>"},{"location":"codegen/scalars/create_scalar/#tutorial-country-scalar","title":"Tutorial - Country scalar","text":"<p>In order to deserialize a scalar for it to be compatible with Qt we created <code>BaseCustomScalar</code>. For example if you have a scalar of country code, you want to show the user a readable value.</p> <p>Here is a simple implementation</p> <p><pre><code>from __future__ import annotations\nfrom qtgql.codegen.py.runtime.custom_scalars import BaseCustomScalar\nfrom typing import Optional\ncountry_map = {\n'isr': 'israel'\n}\n# BaseCustomScalar[&lt;typeof default_value&gt;, &lt;typeof graphql_value&gt;]\nclass CountryCode(BaseCustomScalar[str, str]):\nGRAPHQL_NAME = \"CountryCode\"\nDEFAULT_VALUE = \"israel\"  # this would be the default value.\n@classmethod\ndef from_graphql(cls, v: Optional[str] = None) -&gt; CountryCode:\nif v:\nreturn cls(country_map[v])\nreturn cls()\ndef to_qt(self) -&gt; str:\nreturn self._value\nassert CountryCode.from_graphql('isr').to_qt() == 'israel' == CountryCode().to_qt()\n</code></pre>     !!! Note         You would need to add this in your config     <pre><code># config.py\nfrom qtgql.codegen.py.compiler.config import QtGqlConfig\nQtGqlConfig(custom_scalars={CountryCode.GRAPHQL_NAME: CountryCode}, ...)\n</code></pre></p>"},{"location":"codegen/scalars/create_scalar/#api","title":"API","text":""},{"location":"codegen/scalars/create_scalar/#qtgql.codegen.py.runtime.custom_scalars.BaseCustomScalar","title":"<code>BaseCustomScalar</code>","text":"<p>         Bases: <code>Generic[T, T_RAW]</code>, <code>ABC</code></p> <p>Class to extend by user defined scalars.</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>class BaseCustomScalar(Generic[T, T_RAW], ABC):\n\"\"\"Class to extend by user defined scalars.\"\"\"\n__slots__ = \"_value\"\nGRAPHQL_NAME: str\n\"\"\"The *real* GraphQL name of the scalar (used by the codegen inspection\n    pipeline).\"\"\"\nDEFAULT_VALUE: T\n\"\"\"A place holder graphql query returned null or the field wasn't queried.\n    can be used by `from_graphql()`\n    \"\"\"\ndef __init__(self, v: Optional[T] = None):\nif not v:\nself._value = self.DEFAULT_VALUE\nelse:\nself._value = v\n@abstractmethod\ndef from_graphql(cls, v: Optional[T_RAW] = None) -&gt; \"BaseCustomScalar\":\n\"\"\"Deserializes data fetched from graphql, This is useful when you want\n        to set a first-of value that will later be used by `to_qt()`.\n        **must be overridden**!\n        \"\"\"\nraise NotImplementedError  # pragma: no cover\n@abstractmethod\ndef to_qt(self) -&gt; Any:\n\"\"\"Will be used by the property getter, This is the official value that\n        Qt should \"understand\".\n        **must be overridden**!\n        \"\"\"\nraise NotImplementedError  # pragma: no cover\ndef __ne__(self, other) -&gt; bool:\nassert isinstance(other, BaseCustomScalar), \"can only compare scalar with other scalar.\"\nreturn self._value != other._value\n</code></pre>"},{"location":"codegen/scalars/create_scalar/#qtgql.codegen.py.runtime.custom_scalars.BaseCustomScalar.DEFAULT_VALUE","title":"<code>DEFAULT_VALUE: T</code>  <code>class-attribute</code>","text":"<p>A place holder graphql query returned null or the field wasn't queried.</p> <p>can be used by <code>from_graphql()</code></p>"},{"location":"codegen/scalars/create_scalar/#qtgql.codegen.py.runtime.custom_scalars.BaseCustomScalar.GRAPHQL_NAME","title":"<code>GRAPHQL_NAME: str</code>  <code>class-attribute</code>","text":"<p>The real GraphQL name of the scalar (used by the codegen inspection pipeline).</p>"},{"location":"codegen/scalars/create_scalar/#qtgql.codegen.py.runtime.custom_scalars.BaseCustomScalar.from_graphql","title":"<code>from_graphql(v=None)</code>  <code>abstractmethod</code>","text":"<p>Deserializes data fetched from graphql, This is useful when you want to set a first-of value that will later be used by <code>to_qt()</code>.</p> <p>must be overridden!</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>@abstractmethod\ndef from_graphql(cls, v: Optional[T_RAW] = None) -&gt; \"BaseCustomScalar\":\n\"\"\"Deserializes data fetched from graphql, This is useful when you want\n    to set a first-of value that will later be used by `to_qt()`.\n    **must be overridden**!\n    \"\"\"\nraise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"codegen/scalars/create_scalar/#qtgql.codegen.py.runtime.custom_scalars.BaseCustomScalar.to_qt","title":"<code>to_qt()</code>  <code>abstractmethod</code>","text":"<p>Will be used by the property getter, This is the official value that Qt should \"understand\".</p> <p>must be overridden!</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>@abstractmethod\ndef to_qt(self) -&gt; Any:\n\"\"\"Will be used by the property getter, This is the official value that\n    Qt should \"understand\".\n    **must be overridden**!\n    \"\"\"\nraise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"codegen/scalars/create_scalar/#qtgql.codegen.py.runtime.custom_scalars.DateScalar","title":"<code>DateScalar</code>","text":"<p>         Bases: <code>BaseCustomScalar[date, str]</code></p> <p>An ISO-8601 encoded date.</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>class DateScalar(BaseCustomScalar[date, str]):\n\"\"\"An ISO-8601 encoded date.\"\"\"\nGRAPHQL_NAME = \"Date\"\nDEFAULT_VALUE = date(year=1998, month=8, day=23)\n@classmethod\ndef from_graphql(cls, v=None) -&gt; \"DateScalar\":\nif v:\nreturn cls(date.fromisoformat(v))\nreturn cls()\ndef to_qt(self) -&gt; str:\nreturn self._value.isoformat()\n</code></pre>"},{"location":"codegen/scalars/create_scalar/#qtgql.codegen.py.runtime.custom_scalars.DateTimeScalar","title":"<code>DateTimeScalar</code>","text":"<p>         Bases: <code>BaseCustomScalar[datetime, str]</code></p> <p>An ISO-8601 encoded datetime.</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>class DateTimeScalar(BaseCustomScalar[datetime, str]):\n\"\"\"An ISO-8601 encoded datetime.\"\"\"\nGRAPHQL_NAME: str = \"DateTime\"\nDEFAULT_VALUE = datetime.now()\nFORMAT_STRING = \"%H:%M (%m/%d/%Y)\"\n@classmethod\ndef from_graphql(cls, v=None) -&gt; \"DateTimeScalar\":\nif v:\nreturn cls(datetime.fromisoformat(v))\nreturn cls()\ndef to_qt(self) -&gt; str:\nreturn self._value.strftime(self.FORMAT_STRING)\n</code></pre>"},{"location":"codegen/scalars/create_scalar/#qtgql.codegen.py.runtime.custom_scalars.DecimalScalar","title":"<code>DecimalScalar</code>","text":"<p>         Bases: <code>BaseCustomScalar[Decimal, str]</code></p> <p>A Decimal value serialized as a string.</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>class DecimalScalar(BaseCustomScalar[Decimal, str]):\n\"\"\"A Decimal value serialized as a string.\"\"\"\nGRAPHQL_NAME = \"Decimal\"\nDEFAULT_VALUE = Decimal()\n@classmethod\ndef from_graphql(cls, v: Optional[str] = None) -&gt; \"DecimalScalar\":\nif v:\nreturn cls(Decimal(v))\nreturn cls()\ndef to_qt(self) -&gt; str:\nreturn str(self._value)\n</code></pre>"},{"location":"codegen/scalars/create_scalar/#qtgql.codegen.py.runtime.custom_scalars.TimeScalar","title":"<code>TimeScalar</code>","text":"<p>         Bases: <code>BaseCustomScalar[time, str]</code></p> <p>an ISO-8601 encoded time.</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>class TimeScalar(BaseCustomScalar[time, str]):\n\"\"\"an ISO-8601 encoded time.\"\"\"\nGRAPHQL_NAME = \"Time\"\nDEFAULT_VALUE = time()\n@classmethod\ndef from_graphql(cls, v: Optional[str] = None) -&gt; \"TimeScalar\":\nif v:\nreturn cls(time.fromisoformat(v))\nreturn cls()\ndef to_qt(self) -&gt; str:\nreturn self._value.isoformat()\n</code></pre>"},{"location":"codegen/scalars/custom_scalars/","title":"'Builtins' scalars","text":"<p>QtGQL provides some custom scalars by default, they are intended to be compatible with Strawberry-GraphQL custom scalars, though you can override them.</p>"},{"location":"codegen/scalars/custom_scalars/#qtgql.codegen.py.runtime.custom_scalars.BaseCustomScalar","title":"<code>BaseCustomScalar</code>","text":"<p>         Bases: <code>Generic[T, T_RAW]</code>, <code>ABC</code></p> <p>Class to extend by user defined scalars.</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>class BaseCustomScalar(Generic[T, T_RAW], ABC):\n\"\"\"Class to extend by user defined scalars.\"\"\"\n__slots__ = \"_value\"\nGRAPHQL_NAME: str\n\"\"\"The *real* GraphQL name of the scalar (used by the codegen inspection\n    pipeline).\"\"\"\nDEFAULT_VALUE: T\n\"\"\"A place holder graphql query returned null or the field wasn't queried.\n    can be used by `from_graphql()`\n    \"\"\"\ndef __init__(self, v: Optional[T] = None):\nif not v:\nself._value = self.DEFAULT_VALUE\nelse:\nself._value = v\n@abstractmethod\ndef from_graphql(cls, v: Optional[T_RAW] = None) -&gt; \"BaseCustomScalar\":\n\"\"\"Deserializes data fetched from graphql, This is useful when you want\n        to set a first-of value that will later be used by `to_qt()`.\n        **must be overridden**!\n        \"\"\"\nraise NotImplementedError  # pragma: no cover\n@abstractmethod\ndef to_qt(self) -&gt; Any:\n\"\"\"Will be used by the property getter, This is the official value that\n        Qt should \"understand\".\n        **must be overridden**!\n        \"\"\"\nraise NotImplementedError  # pragma: no cover\ndef __ne__(self, other) -&gt; bool:\nassert isinstance(other, BaseCustomScalar), \"can only compare scalar with other scalar.\"\nreturn self._value != other._value\n</code></pre>"},{"location":"codegen/scalars/custom_scalars/#qtgql.codegen.py.runtime.custom_scalars.BaseCustomScalar.DEFAULT_VALUE","title":"<code>DEFAULT_VALUE: T</code>  <code>class-attribute</code>","text":"<p>A place holder graphql query returned null or the field wasn't queried.</p> <p>can be used by <code>from_graphql()</code></p>"},{"location":"codegen/scalars/custom_scalars/#qtgql.codegen.py.runtime.custom_scalars.BaseCustomScalar.GRAPHQL_NAME","title":"<code>GRAPHQL_NAME: str</code>  <code>class-attribute</code>","text":"<p>The real GraphQL name of the scalar (used by the codegen inspection pipeline).</p>"},{"location":"codegen/scalars/custom_scalars/#qtgql.codegen.py.runtime.custom_scalars.BaseCustomScalar.from_graphql","title":"<code>from_graphql(v=None)</code>  <code>abstractmethod</code>","text":"<p>Deserializes data fetched from graphql, This is useful when you want to set a first-of value that will later be used by <code>to_qt()</code>.</p> <p>must be overridden!</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>@abstractmethod\ndef from_graphql(cls, v: Optional[T_RAW] = None) -&gt; \"BaseCustomScalar\":\n\"\"\"Deserializes data fetched from graphql, This is useful when you want\n    to set a first-of value that will later be used by `to_qt()`.\n    **must be overridden**!\n    \"\"\"\nraise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"codegen/scalars/custom_scalars/#qtgql.codegen.py.runtime.custom_scalars.BaseCustomScalar.to_qt","title":"<code>to_qt()</code>  <code>abstractmethod</code>","text":"<p>Will be used by the property getter, This is the official value that Qt should \"understand\".</p> <p>must be overridden!</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>@abstractmethod\ndef to_qt(self) -&gt; Any:\n\"\"\"Will be used by the property getter, This is the official value that\n    Qt should \"understand\".\n    **must be overridden**!\n    \"\"\"\nraise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"codegen/scalars/custom_scalars/#qtgql.codegen.py.runtime.custom_scalars.DateScalar","title":"<code>DateScalar</code>","text":"<p>         Bases: <code>BaseCustomScalar[date, str]</code></p> <p>An ISO-8601 encoded date.</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>class DateScalar(BaseCustomScalar[date, str]):\n\"\"\"An ISO-8601 encoded date.\"\"\"\nGRAPHQL_NAME = \"Date\"\nDEFAULT_VALUE = date(year=1998, month=8, day=23)\n@classmethod\ndef from_graphql(cls, v=None) -&gt; \"DateScalar\":\nif v:\nreturn cls(date.fromisoformat(v))\nreturn cls()\ndef to_qt(self) -&gt; str:\nreturn self._value.isoformat()\n</code></pre>"},{"location":"codegen/scalars/custom_scalars/#qtgql.codegen.py.runtime.custom_scalars.DateTimeScalar","title":"<code>DateTimeScalar</code>","text":"<p>         Bases: <code>BaseCustomScalar[datetime, str]</code></p> <p>An ISO-8601 encoded datetime.</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>class DateTimeScalar(BaseCustomScalar[datetime, str]):\n\"\"\"An ISO-8601 encoded datetime.\"\"\"\nGRAPHQL_NAME: str = \"DateTime\"\nDEFAULT_VALUE = datetime.now()\nFORMAT_STRING = \"%H:%M (%m/%d/%Y)\"\n@classmethod\ndef from_graphql(cls, v=None) -&gt; \"DateTimeScalar\":\nif v:\nreturn cls(datetime.fromisoformat(v))\nreturn cls()\ndef to_qt(self) -&gt; str:\nreturn self._value.strftime(self.FORMAT_STRING)\n</code></pre>"},{"location":"codegen/scalars/custom_scalars/#qtgql.codegen.py.runtime.custom_scalars.DecimalScalar","title":"<code>DecimalScalar</code>","text":"<p>         Bases: <code>BaseCustomScalar[Decimal, str]</code></p> <p>A Decimal value serialized as a string.</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>class DecimalScalar(BaseCustomScalar[Decimal, str]):\n\"\"\"A Decimal value serialized as a string.\"\"\"\nGRAPHQL_NAME = \"Decimal\"\nDEFAULT_VALUE = Decimal()\n@classmethod\ndef from_graphql(cls, v: Optional[str] = None) -&gt; \"DecimalScalar\":\nif v:\nreturn cls(Decimal(v))\nreturn cls()\ndef to_qt(self) -&gt; str:\nreturn str(self._value)\n</code></pre>"},{"location":"codegen/scalars/custom_scalars/#qtgql.codegen.py.runtime.custom_scalars.TimeScalar","title":"<code>TimeScalar</code>","text":"<p>         Bases: <code>BaseCustomScalar[time, str]</code></p> <p>an ISO-8601 encoded time.</p> Source code in <code>qtgql/codegen/py/runtime/custom_scalars.py</code> <pre><code>class TimeScalar(BaseCustomScalar[time, str]):\n\"\"\"an ISO-8601 encoded time.\"\"\"\nGRAPHQL_NAME = \"Time\"\nDEFAULT_VALUE = time()\n@classmethod\ndef from_graphql(cls, v: Optional[str] = None) -&gt; \"TimeScalar\":\nif v:\nreturn cls(time.fromisoformat(v))\nreturn cls()\ndef to_qt(self) -&gt; str:\nreturn self._value.isoformat()\n</code></pre>"},{"location":"helpers/itemsystem/","title":"Introduction","text":"<p>In order to generate a <code>QAbstractListModel</code> with ease you can use our \"itemsystem\" framework.</p> <p>Say we want to show a model apples and apples might have worms inside so there is a worm model as well.</p> <p>Any class that extends <code>MyBaseType</code> would automatically generate a QAbstractListModel with the proper roles in it.</p> <pre><code>from __future__ import annotations\nfrom PySide6.QtCore import QObject, Property, QCoreApplication\nfrom qtgql.tools.itemsystem import get_base_type, role, GenericModel, asdict\nMyBaseType = get_base_type()\nclass Apple(MyBaseType):\ncolor: str = role()\nsize: int = role()\nworms: GenericModel[Worm]\n</code></pre> Note <p>We haven't defined Worm yet, though <code>MyBaseType</code> can handle lazy definitions.</p> <pre><code>class Worm(MyBaseType):\nname: str = role()\ncolor: str = role(default=\"green\")\nclass MyApp(QObject):\ndef __init__(self):\nsuper().__init__(None)\ndata = asdict(Apple(color='red', size=12, worms=[asdict(Worm(name='steve')) for _ in range(5)]))\nself._apple_model: GenericModel[Apple] = Apple.Model(data=[data])\n# expose the model to QML:\n@Property(type=QObject, constant=True)\ndef appleModel(self) -&gt; GenricModel[Apple]:\nreturn self._apple_model\ndef check_apple_color(self):\n# `color` is auto completed!\nassert self._apple_model._data[0].color == 'red'\nself.deleteLater()\napp = MyApp()\nassert app._apple_model is app.appleModel\napp.check_apple_color()\n</code></pre>"},{"location":"helpers/itemsystem/#tools.itemsystem.GenericModel","title":"<code>GenericModel</code>","text":"<p>         Bases: <code>Generic[_TBaseType]</code>, <code>QAbstractListModel</code></p> <p>Contains logic autogenerated models that extends <code>_BaseType</code> You don't need to use this class directly.</p> <p>Although you would need it to annotate \"child\" roles. i.e:</p> <pre><code>from qtgql.tools.itemsystem import get_base_type, GenericModel\nBaseType = get_base_type()\nclass SomeModel(BaseType):\nother_model: GenericModel['OtherModel']\n</code></pre> Source code in <code>tools/itemsystem.py</code> <pre><code>class GenericModel(Generic[_TBaseType], QAbstractListModel):\n\"\"\"Contains logic autogenerated models that extends `_BaseType` You don't\n    need to use this class directly.\n    Although you would need it to annotate \"child\" roles. i.e:\n    ```python\n    from qtgql.tools.itemsystem import get_base_type, GenericModel\n    BaseType = get_base_type()\n    class SomeModel(BaseType):\n         other_model: GenericModel['OtherModel']\n    ```\n    \"\"\"\n__roledefined_type__: type[_TBaseType]\n__roles__: RoleMapper\nlayoutAboutToBeChanged: Signal\nlayoutChanged: Signal\ndataChanged: Callable[[QModelIndex, QModelIndex, Optional[list[int]]], None]\ndef __init__(self, *, data: Optional[Union[list[dict], dict]] = None, parent=None):\nsuper().__init__(parent)\nself.rowsAb = None\nself.parent_model: Optional[GenericModel] = parent\nself.type_ = self.__roledefined_type__\nself._data: list[_TBaseType] = []\nself._child_models: list[GenericModel[Any]] = []\nif data:\nself.initialize_data(data)\ndef initialize_data(self, data: Union[list[dict], dict]) -&gt; None:\n\"\"\":param data: data to generate the model\"\"\"\nself.layoutAboutToBeChanged.emit()\nQEventLoop().processEvents()\n# search for children and initialize them as models\nfor node in data:\nif children := self.__roles__.children:\nfor name, child in children.items():\nchild_data = node[name]\nchild_model = child.Model(data=child_data, parent=self)\nnode[name] = child_model\n#  save child models for further use.\nself._child_models.append(child_model)\n# initialize list of attrs classes\nfor node in data:\ninst = self.type_(**node)  # type: ignore\nself._data.append(inst)\nself.layoutChanged.emit()\ndef data(self, index, role=...):\nif index.row() &lt; len(self._data) and index.isValid():\ntry:\nreturn getattr(self._data[index.row()], self.__roles__.by_num[role].name, None)\nexcept KeyError as exc:\nif role in (\n-1,\nQt.ItemDataRole.DisplayRole,\nQt.ItemDataRole.ToolTipRole,\nQt.ItemDataRole.StatusTipRole,\nQt.ItemDataRole.WhatsThisRole,\nQt.ItemDataRole.SizeHintRole,\nQt.ItemDataRole.FontRole,\nQt.ItemDataRole.BackgroundRole,\nQt.ItemDataRole.ForegroundRole,\nQt.ItemDataRole.DecorationRole,\nQt.ItemDataRole.TextAlignmentRole,\nQt.ItemDataRole.CheckStateRole,\n):\nreturn None\n# resolvers should be pre-evaluated when the model updated\nraise RoleDoesNotExist(\nf\"role {role} of type {self.type_} at index: [{index}] \"\nf\"is not a valid role!\\n\"\nf\"options are: {self.__roles__.qt_roles}\"\n) from exc\ndef setData(self, index, value, role=...):\nif index.row() &lt; len(self._data) and index.isValid():\nsetattr(self._data[index.row()], self.__roles__.by_num[role].name, value)\nreturn True\nreturn False\ndef flags(self, index):\nif index.row() &lt; len(self._data) and index.isValid():\nreturn Qt.ItemFlag.ItemIsEditable\nreturn Qt.ItemFlag.NoItemFlags\ndef roleNames(self) -&gt; dict:\nreturn self.__roles__.qt_roles\ndef rowCount(self, parent=...) -&gt; int:\nreturn len(self._data)\ndef append(self, node: _TBaseType) -&gt; None:\ncount = self.rowCount()\nself.beginInsertRows(self.index(count), count, count)\nself._data.append(node)\nself.endInsertRows()\n@slot\ndef pop(self, index: Optional[int] = None) -&gt; None:\nindex = -1 if index is None else index\nreal_index = index if index &gt; -1 else self.rowCount()\nself.beginRemoveRows(self.index(index - 1).parent(), real_index, real_index)\nself._data.pop(index)\nself.endRemoveRows()\n@slot\ndef clear(self) -&gt; None:\nif self._data:\nself.beginRemoveRows(self.index(0).parent(), 0, self.rowCount())\nfor child in self._child_models:\nchild.clear()\nself._data = []\nself.endRemoveRows()\n@slot\ndef get_by_index(self, row: int, key: str) -&gt; Any:\nreturn self.data(self.index(row), self.__roles__.by_name[key].num)\n# CLASS METHODS\n@classmethod\ndef from_role_defined(\ncls, type_: type[_BaseType], parent: Optional[Type[GenericModel]] = None\n) -&gt; type[GenericModel]:\nbases = (cls,)\nif parent:\nbases = (parent,)\nret = type(cls.name_by_type(type_), bases, {\"__roledefined_type__\": type_})\nassert issubclass(ret, GenericModel)\nreturn ret\n@classmethod\ndef name_by_type(cls, type_: type) -&gt; str:\nreturn type_.__name__ + \"Model\"\n</code></pre>"},{"location":"helpers/itemsystem/#tools.itemsystem.GenericModel.initialize_data","title":"<code>initialize_data(data)</code>","text":"<p>:param data: data to generate the model</p> Source code in <code>tools/itemsystem.py</code> <pre><code>def initialize_data(self, data: Union[list[dict], dict]) -&gt; None:\n\"\"\":param data: data to generate the model\"\"\"\nself.layoutAboutToBeChanged.emit()\nQEventLoop().processEvents()\n# search for children and initialize them as models\nfor node in data:\nif children := self.__roles__.children:\nfor name, child in children.items():\nchild_data = node[name]\nchild_model = child.Model(data=child_data, parent=self)\nnode[name] = child_model\n#  save child models for further use.\nself._child_models.append(child_model)\n# initialize list of attrs classes\nfor node in data:\ninst = self.type_(**node)  # type: ignore\nself._data.append(inst)\nself.layoutChanged.emit()\n</code></pre>"},{"location":"helpers/itemsystem/#tools.itemsystem.Role","title":"<code>Role</code>","text":"<p>Provides metadata about a field in a define_roles decorated class.</p> Source code in <code>tools/itemsystem.py</code> <pre><code>class Role:\n\"\"\"Provides metadata about a field in a define_roles decorated class.\"\"\"\n__slots__ = (\"num\", \"name\", \"qt_name\", \"_type\", \"str_type\", \"type_map\")\ndef __init__(self, num: int, name: str, type: Union[TypeHinter, str], type_map: dict):\nself.num = num\nself.name = name\nself.qt_name = QByteArray(name.encode(\"utf-8\"))\nself.type_map = type_map\nif isinstance(type, str):\nself.str_type = type\nelse:\nself._type = TypeHinter.from_annotations(type)\n@property\ndef type(self) -&gt; TypeHinter:\ntry:\nreturn self._type\nexcept AttributeError:\nself._type = TypeHinter.from_string(self.str_type, ns=self.type_map)\nreturn self._type\n</code></pre>"},{"location":"helpers/itemsystem/#tools.itemsystem.RoleMapper","title":"<code>RoleMapper</code>","text":"<p>A container that maps the roles of a defined class each map has a certain usage in the future.</p> Source code in <code>tools/itemsystem.py</code> <pre><code>class RoleMapper:\n\"\"\"A container that maps the roles of a defined class each map has a\n    certain usage in the future.\"\"\"\ndef __init__(self) -&gt; None:\n# this is the real name of the field\n# how the class would be created\nself.by_name: dict[str, Role] = {}\n# number is  a qt role 256+\n# this is how qml will call the data() method\nself.by_num: dict[int, Role] = {}\n# just to return to qt method roleNames()\nself.qt_roles: dict[int, QByteArray] = {}\n@cached_property\ndef children(self) -&gt; dict[str, type[_BaseType]]:\n# mapping all the roledefined to know for what\n# to initialize a genericModel\nret = {}\nfor role_ in self.by_name.values():\n# lists must be child models\nif role_.type.type is GenericModel:\nchild_type = role_.type.of_type[0].type\nret[role_.name] = child_type\nreturn ret\n</code></pre>"},{"location":"helpers/itemsystem/#tools.itemsystem.get_base_type","title":"<code>get_base_type(name='Default')</code>","text":"<p>:return: BaseType to use for generating <code>GenericModel</code>'s</p> Source code in <code>tools/itemsystem.py</code> <pre><code>def get_base_type(name: str = \"Default\") -&gt; type[_BaseType]:\n\"\"\":return: BaseType to use for generating `GenericModel`'s\"\"\"\ncls: type[_BaseType] = types.new_class(name=f\"{name}BaseType\", kwds={\"metaclass\": BaseTypeMeta})\n# we need to inject this here in order for `get_type_hints()` to work.\ncls.__types_map__ = {GenericModel.__name__: GenericModel}  # type: ignore\nreturn cls\n</code></pre>"},{"location":"helpers/itemsystem/#tools.itemsystem.role","title":"<code>role(default=None, factory=UNSET)</code>","text":"<p>role is optional by default.</p> Source code in <code>tools/itemsystem.py</code> <pre><code>def role(\ndefault=None,\nfactory=UNSET,\n):\n\"\"\"role is optional by default.\"\"\"\nif factory is not UNSET:\ndefault = UNSET\nreturn attrs.field(\ndefault=attrs.NOTHING if default is UNSET else default,\nfactory=None if factory is UNSET else factory,\nmetadata={IS_ROLE: True},\n)\n</code></pre>"},{"location":"helpers/utilities/","title":"Utils","text":""},{"location":"helpers/utilities/#utilities","title":"Utilities","text":"<p>general helpers for ease of development.</p>"},{"location":"helpers/utilities/#slot","title":"slot","text":"<p>Creates a slot out of type annotation.</p> <p><pre><code>from qtgql.tools import slot\nfrom PySide6.QtCore import QObject\nclass Foo(QObject):\ndef __init__(self):\nsuper().__init__(None)\nself.data: str = 'foo'\n@slot\ndef set_data_from_qml(self, text: str) -&gt; None:\n\"\"\"\n        This is reachable from QML!\n        \"\"\"\nself.data = text\nfoo = Foo()\nfoo.set_data_from_qml('bar')\nassert foo.data == 'bar'\n</code></pre> </p> Source code in <code>tools/slot.py</code> <pre><code>def slot(func: T_Callable) -&gt; T_Callable:\ndef wrapper(func) -&gt; T_Callable:\nanots: dict = get_type_hints(func)\nreturn_ = TypeHinter.from_annotations(anots.pop(\"return\", None))\nif return_.type is type(None):\nret_type = None\nelif return_.type is Any:\nret_type = \"QVariant\"\nelse:\nret_type = return_.type\nargs = [TypeHinter.from_annotations(th) for th in anots.values()]\nstripped_optionals = [th.of_type[0] for th in args if th.is_optional()]\nconcretes = [th for th in args if not th.is_optional()]\nif stripped_optionals:\ncombos = get_combos(stripped_optionals, concretes)\nfor combo in combos:\nfunc = QtCore.Slot(*combo, result=ret_type)(func)\nreturn func\nreturn QtCore.Slot(*[th.type for th in concretes], result=ret_type)(func)\nreturn wrapper(func)\n</code></pre>"},{"location":"helpers/utilities/#auto-property","title":"Auto-property","text":"<p>Create Properties with a dataclass syntax</p> <p>Example: <pre><code>from qtgql.tools import define_properties\n@define_properties\nclass Apple:\ncolor: str\nsize: int\napple = Apple(color=\"red\", size=92)\napple_as_qt: Apple = apple.properties\nassert apple_as_qt.color == apple.color\napple.color = \"green\"\nassert apple_as_qt.color == \"green\"\n</code></pre></p> <p>:param cls: Class that implements dataclass syntax - (PEP 681). :return: <code>@attrs.define</code> decorated class with properties field injected.  this field is a <code>QObject</code> that will emit signals when you set attribute on that class  and is use-able via QML and other parts of QT.</p> Source code in <code>tools/autoproperty.py</code> <pre><code>@dataclass_transform(\nfield_specifiers=(attr.attrib, attr.field),\n)\ndef define_properties(cls: Union[Type[T], Type[MakeProperties]]) -&gt; Type[BasePropertyClass]:\n\"\"\"\n    :param cls: Class that implements dataclass syntax - (PEP 681).\n    :return: `@attrs.define` decorated class with properties field injected.\n     this field is a `QObject` that will emit signals when you set attribute on that class\n     and is use-able via QML and other parts of QT.\n    \"\"\"\nns = cls.__dict__.copy()\nbases = cls.__bases__ if cls.__bases__ != (object,) else (MakeProperties,)\ncls = type(cls.__name__, bases, ns)\ndef post_init(self: BasePropertyClass):\nself.properties = self.PropertiesClass_(self)\ncls.__attrs_post_init__ = post_init  # type: ignore\nreturn cast(Type[BasePropertyClass], define(cls, on_setattr=attrs_compat_setter))\n</code></pre>"}]}